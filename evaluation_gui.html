<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA Evaluation Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 25px;
            color: white;
        }

        .title {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            color: white;
        }

        .instructions {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: none;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            color: #1565c0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .instructions h3 {
            color: #1565c0;
            margin-bottom: 20px;
            font-size: 1.4rem;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .color-guide {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.4);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .color-guide span {
            font-weight: bold;
        }

        .green { color: #28a745; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        .blue { color: #17a2b8; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        .red { color: #dc3545; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }

        .main-content {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 35px;
            margin-bottom: 25px;
            color: #1565c0;
        }

        .question-header {
            margin-bottom: 35px;
        }

        .question-header h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #1565c0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .question-text {
            font-size: 1.3rem;
            background: rgba(255,255,255,0.6);
            padding: 20px;
            border-radius: 12px;
            border-left: 6px solid #2196f3;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .section {
            margin-bottom: 45px;
        }

        .section h3 {
            font-size: 1.6rem;
            margin-bottom: 25px;
            color: #1565c0;
            border-bottom: 3px solid rgba(33, 150, 243, 0.3);
            padding-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 35px;
        }

        .column {
            background: rgba(255,255,255,0.6);
            padding: 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(33, 150, 243, 0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .column h4 {
            margin-bottom: 20px;
            color: #1565c0;
            font-size: 1.3rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .fact-item {
            display: flex;
            align-items: center;
            margin-bottom: 18px;
            padding: 15px;
            background: rgba(255,255,255,0.7);
            border-radius: 10px;
            border: 1px solid rgba(33, 150, 243, 0.2);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .fact-item:hover {
            background: rgba(255,255,255,0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }

        .fact-checkbox {
            margin-right: 18px;
            margin-top: 3px;
            transform: scale(1.2);
        }

        .fact-text {
            flex: 1;
            font-size: 1.1rem;
            color: #1565c0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .not-mentioned-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 18px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .not-mentioned-btn:hover {
            background: linear-gradient(135deg, #5a6268 0%, #6c757d 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .not-mentioned-btn.active {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .not-mentioned-btn.active:hover {
            background: linear-gradient(135deg, #c82333 0%, #dc3545 100%);
        }

        .relevance-accurate {
            margin-left: 15px;
            display: flex;
            align-items: center;
        }

        .relevance-accurate label {
            font-size: 0.9rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .evaluation-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
            align-items: start;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.6);
            border-radius: 12px;
            border: 1px solid rgba(76, 175, 80, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .evaluation-row:hover {
            background: rgba(255,255,255,0.8);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }

        .fact-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .not-mentioned-inside {
            margin-top: 4px;
            margin-left: 30px;
        }

        .not-mentioned-inside label {
            font-size: 0.9rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(44, 85, 48, 0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .evaluation-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .correctness-container {
            margin-bottom: 25px;
        }

        .not-mentioned-outside {
            margin-top: 15px;
            padding: 12px 18px;
            background: rgba(255,255,255,0.6);
            border-radius: 10px;
            border: 1px solid rgba(76, 175, 80, 0.2);
            backdrop-filter: blur(10px);
        }

        .not-mentioned-outside label {
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(44, 85, 48, 0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .evaluation-row.faded {
            opacity: 0.5;
            filter: grayscale(60%);
            background: rgba(255,255,255,0.3);
        }

        .evaluation-row.faded .fact-checkbox {
            pointer-events: none;
        }

        .evaluation-row.faded .not-mentioned-btn {
            pointer-events: auto;
        }

        .evaluation-row.faded .not-mentioned-inside {
            pointer-events: auto;
        }

        .evaluation-row.faded .not-mentioned-inside input[type="checkbox"] {
            pointer-events: auto;
        }

        .not-mentioned-section {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .not-mentioned-section label {
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(44, 85, 48, 0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .checkbox-group label {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(44, 85, 48, 0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .checkbox-group input[type="checkbox"] {
            margin: 0;
            transform: scale(1.3);
        }

        .fact-item.faded {
            opacity: 0.5;
            filter: grayscale(60%);
            background: rgba(255,255,255,0.3);
        }

        .fact-item.faded .fact-checkbox {
            pointer-events: none;
        }

        .fact-item.faded .not-mentioned-btn {
            pointer-events: auto;
        }

        /* Enhanced checkbox styling */
        input[type="checkbox"] {
            accent-color: #4caf50;
            transform: scale(1.2);
            transition: all 0.3s ease;
        }

        input[type="checkbox"]:checked {
            animation: checkboxPulse 0.3s ease;
        }

        @keyframes checkboxPulse {
            0% { transform: scale(1.2); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1.2); }
        }

        /* Resume dialog styling */
        .resume-dialog {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(33, 150, 243, 0.3);
        }

        .resume-dialog h3 {
            color: #1565c0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .resume-dialog p {
            color: rgba(21, 101, 192, 0.8);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .resume-dialog button {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .resume-dialog button:hover {
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .resume-dialog button#startNewBtn {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
        }

        .resume-dialog button#startNewBtn:hover {
            background: linear-gradient(135deg, #5a6268 0%, #6c757d 100%);
        }

        .sidebar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            padding: 25px;
            color: #1565c0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(33, 150, 243, 0.2);
        }

        .sidebar h3 {
            margin-bottom: 20px;
            color: #1565c0;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .nav-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #5a6268 0%, #6c757d 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            background: linear-gradient(135deg, #e0e0e0 0%, #d0d0d0 100%);
            color: #9e9e9e;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.4);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2196f3 0%, #1976d2 50%, #1565c0 100%);
            transition: width 0.5s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .progress-text {
            text-align: center;
            font-size: 1rem;
            color: #1565c0;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .expandable {
            margin-bottom: 20px;
        }

        .expandable-header {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 15px 20px;
            cursor: pointer;
            border-radius: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #1565c0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .expandable-header:hover {
            background: linear-gradient(135deg, #bbdefb 0%, #e3f2fd 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .expandable-content {
            padding: 20px;
            background: rgba(255,255,255,0.6);
            border: 1px solid rgba(33, 150, 243, 0.2);
            border-top: none;
            border-radius: 0 0 10px 10px;
            display: none;
            backdrop-filter: blur(10px);
            color: #1565c0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .expandable-content.show {
            display: block;
        }

        .divider {
            height: 3px;
            background: linear-gradient(90deg, transparent 0%, rgba(33, 150, 243, 0.3) 50%, transparent 100%);
            margin: 40px 0;
            border-radius: 2px;
        }

        .success-message {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            display: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .error-message {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            display: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .thank-you-page {
            text-align: center;
            padding: 80px 30px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
            margin: 30px 0;
            display: none;
            position: relative;
            overflow: hidden;
        }

        .thank-you-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(33,150,243,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(33,150,243,0.1)"/><circle cx="50" cy="10" r="0.5" fill="rgba(33,150,243,0.1)"/><circle cx="10" cy="60" r="0.5" fill="rgba(33,150,243,0.1)"/><circle cx="90" cy="40" r="0.5" fill="rgba(33,150,243,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
        }

        .thank-you-page h1 {
            font-size: 3.5rem;
            margin-bottom: 25px;
            font-weight: 700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1;
            color: #1565c0;
        }

        .thank-you-page h2 {
            font-size: 2rem;
            margin-bottom: 35px;
            font-weight: 400;
            opacity: 0.8;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1;
            color: #1565c0;
        }

        .thank-you-page p {
            font-size: 1.3rem;
            margin-bottom: 35px;
            opacity: 0.8;
            line-height: 1.7;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1;
            color: #1565c0;
        }

        .evaluation-id {
            background: rgba(255,255,255,0.6);
            padding: 20px 30px;
            border-radius: 15px;
            margin: 25px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            border: 2px solid rgba(33, 150, 243, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1;
            color: #1565c0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin: 40px 0;
            position: relative;
            z-index: 1;
        }

        .stat-card {
            background: rgba(255,255,255,0.6);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid rgba(33, 150, 243, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            background: rgba(255,255,255,0.8);
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.2);
        }

        .stat-number {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            background: linear-gradient(45deg, #1565c0, #1976d2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            color: #1565c0;
        }

        .restart-btn {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
            border: 2px solid rgba(33, 150, 243, 0.3);
            padding: 18px 35px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }

        .restart-btn:hover {
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%);
            border-color: rgba(33, 150, 243, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.2);
        }

        /* Annotator name input styling */
        #annotatorName {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            width: 200px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #annotatorName::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        #annotatorName:focus {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            outline: none;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        /* Auto-save indicator enhancement */
        #autoSaveIndicator {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%) !important;
            border: 2px solid rgba(33, 150, 243, 0.3) !important;
            backdrop-filter: blur(10px) !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2) !important;
            font-weight: bold !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3) !important;
        }

        @media (max-width: 1200px) {
            .two-column {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: static;
                width: 100%;
                margin-top: 20px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .evaluation-row {
                grid-template-columns: 1fr;
            }
            
            .evaluation-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">Question Answering Evaluation!!</h1>
            <div style="margin-top: 15px;">
                <label for="annotatorName" style="font-weight: bold; margin-right: 10px;">Annotator Name:</label>
                <input type="text" id="annotatorName" placeholder="Enter your name">
            </div>
        </div>

        <div class="instructions" id="instructionsSection">
            <!-- Instructions will be dynamically updated based on current step -->
        </div>

        <div class="main-content" id="mainContent">
            <!-- Content will be dynamically generated -->
        </div>

        <div class="thank-you-page" id="thankYouPage">
            <h1>🎉 Thank You!</h1>
            <h2>Your evaluation has been completed successfully</h2>
            <p>Thank you for taking the time to evaluate the AI assistant responses. Your feedback is invaluable for improving the quality of AI-generated answers.</p>
            
            <div class="evaluation-id" id="evaluationIdDisplay">
                Evaluation ID: <span id="evaluationIdSpan"></span>
            </div>
            
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated dynamically -->
            </div>
            
            <button class="restart-btn" onclick="restartEvaluation()">Start New Evaluation</button>
        </div>

        <div class="success-message" id="successMessage">
            Results successfully saved!
        </div>

        <div class="error-message" id="errorMessage">
            Error loading data. Please check the file paths and try again.
        </div>
    </div>

    <div class="sidebar">
        <h3>Navigation</h3>
        <div class="nav-buttons">
            <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()">⬅️ Previous</button>
            <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()">Next ➡️</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">Question 1 of 1</div>
        
        <button class="btn btn-primary" style="width: 100%;" onclick="finishAndSave()">Finish and Save Results</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyBVQx7l8alDEWRW9qpxAPrgXiSeNtc6NHc",
          authDomain: "ai-evaluation-82fc8.firebaseapp.com",
          projectId: "ai-evaluation-82fc8",
          storageBucket: "ai-evaluation-82fc8.appspot.com",
          messagingSenderId: "5824392171",
          appId: "1:5824392171:web:dbe5090e30248c5e1547ae",
          measurementId: "G-HR0NVE9J9L"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // Try to sign in anonymously, but don't block the app if it fails
        auth.signInAnonymously()
            .then(() => {
                console.log('Signed in anonymously to Firebase');
            })
            .catch((error) => {
                console.error('Error signing in anonymously:', error);
                console.log('Continuing without Firebase authentication - some features may be limited');
            });

        // Global state
        let questions = [];
        let currentIndex = 0;
        let currentStep = 1; // Track current step (1, 2, or 3)
        let results = {};
        let sessionId = null; // Unique session ID for this evaluation
        let isResuming = false; // Flag to track if we're resuming a session

        // Configuration
        const MANUAL_FILE = 'key points/manual_answer_key_facts_10percent copy.json';
        const MODEL_FILE = 'key points/model_answer_key_facts_gemini_rag_10percent copy.json';
        const OUTPUT_FILE = 'evaluation_results.json';
        const SAMPLE_FRACTION = 1.0; // Select all questions

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadAndPrepareData();
            checkForExistingSessions();
        });

        function loadAndPrepareData() {
            // Try to load data from JSON files and sample 10%
            Promise.all([
                fetch(MANUAL_FILE),
                fetch(MODEL_FILE)
            ])
            .then(responses => {
                // Check if responses are ok
                if (!responses[0].ok || !responses[1].ok) {
                    throw new Error('Files not found or not accessible');
                }
                return Promise.all(responses.map(r => r.json()));
            })
            .then(([manualData, modelData]) => {
                // Combine and sample 10% of the data
                questions = sampleQuestions(manualData, modelData, SAMPLE_FRACTION);
                updateUI();
            })
            .catch(error => {
                console.error('Error loading data:', error);
                console.log('Falling back to sample data due to CORS restrictions or file access issues.');
                console.log('To use real data, serve this HTML file through a local web server.');
                
                // Fallback to sample data
                questions = createSampleData();
                updateUI();
                
                // Show info message instead of error
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = 'Using sample data. To load real data, serve this file through a local web server (e.g., python -m http.server).';
                errorDiv.style.display = 'block';
                errorDiv.style.background = '#d1ecf1';
                errorDiv.style.color = '#0c5460';
            });
        }

        function createSampleData() {
            // Sample data structure for fallback
            return [
                {
                    id: "q1",
                    question: "How do I charge my Tesla vehicle?",
                    manual_answer: "To charge your Tesla vehicle, you can use a Supercharger, home charging station, or standard electrical outlet. The charging time varies based on the method used.",
                    model_answer: "You can charge your Tesla using Superchargers, home chargers, or standard outlets. Superchargers provide the fastest charging.",
                    key_facts_manual: {
                        essential: [
                            "Use Supercharger for fast charging",
                            "Home charging station available",
                            "Standard electrical outlet compatible"
                        ],
                        optional: [
                            "Charging time varies by method",
                            "Mobile app can monitor charging"
                        ],
                        safety_critical: [
                            "Follow safety guidelines when charging"
                        ]
                    },
                    key_facts_model: {
                        essential: [
                            "Superchargers provide fastest charging",
                            "Home chargers available",
                            "Standard outlets can be used"
                        ],
                        optional: [
                            "Charging speed varies",
                            "Multiple charging options exist"
                        ],
                        safety_critical: [
                            "Safety guidelines followed"
                        ]
                    }
                },
                {
                    id: "q2",
                    question: "What should I do if my Tesla won't start?",
                    manual_answer: "If your Tesla won't start, check the battery level, ensure the key fob is present, and try rebooting the system. Contact Tesla support if issues persist.",
                    model_answer: "Check battery level and key fob. Try rebooting the system. Contact support if problems continue.",
                    key_facts_manual: {
                        essential: [
                            "Check battery level",
                            "Ensure key fob is present",
                            "Try rebooting the system"
                        ],
                        optional: [
                            "Contact Tesla support if issues persist",
                            "Check for error messages"
                        ],
                        safety_critical: [
                            "Do not attempt repairs yourself"
                        ]
                    },
                    key_facts_model: {
                        essential: [
                            "Check battery level",
                            "Ensure key fob is present",
                            "Try rebooting the system"
                        ],
                        optional: [
                            "Contact support if problems continue",
                            "Look for error indicators"
                        ],
                        safety_critical: [
                            "Safety guidelines followed"
                        ]
                    }
                }
            ];
        }

        function sampleQuestions(manualData, modelData, sampleFraction) {
            // Get all question IDs
            const allQuestionIds = Object.keys(manualData);
            
            // Calculate how many questions to select
            const totalQuestions = allQuestionIds.length;
            const sampleSize = Math.max(1, Math.floor(totalQuestions * sampleFraction));
            
            // Select questions without shuffling
            const sampledIds = allQuestionIds.slice(0, sampleSize);
            
            console.log(`Selected ${sampleSize} of ${totalQuestions} questions (${(sampleFraction * 100).toFixed(1)}%) without shuffling.`);
            
            // Create question objects from sampled data
            return sampledIds.map(id => {
                const manual = manualData[id];
                const model = modelData[id];
                
                return {
                    id: id,
                    question: manual.question || model.question || `Question ${id}`,
                    manual_answer: manual.manual_answer || manual.answer || '',
                    model_answer: model.model_answer || model.answer || '',
                    key_facts_manual: {
                        essential: manual.key_facts?.essential || [],
                        optional: manual.key_facts?.optional || [],
                        safety_critical: manual.key_facts?.safety_critical || []
                    },
                    key_facts_model: {
                        essential: model.key_facts?.essential || [],
                        optional: model.key_facts?.optional || [],
                        safety_critical: model.key_facts?.safety_critical || []
                    }
                };
            });
        }

        function updateUI() {
            if (!questions || questions.length === 0) {
                document.getElementById('errorMessage').style.display = 'block';
                return;
            }

            const currentQuestion = questions[currentIndex];
            const mainContent = document.getElementById('mainContent');
            
            // Update instructions based on current step
            updateInstructions();
            
            let stepContent = '';
            
            if (currentStep === 1) {
                stepContent = `
                    <div class="question-header">
                        <h2>Question ${currentIndex + 1}/${questions.length}</h2>
                    </div>

                    <!-- Step 1: Completeness -->
                    <div class="section">
                        <h3>Step 1: Evaluate Key Fact Coverage <span style="font-size: 0.8em; font-weight: normal;">(completeness and risk awareness)</span></h3>
                        <div class="question-text">${currentQuestion.question}</div>
                        
                        <div class="two-column">
                            <div class="column">
                                <div class="expandable">
                                    <div class="expandable-header" onclick="toggleExpandable('gtAnswer')">
                                        Show Full Ground Truth Answer
                                        <span>▼</span>
                                    </div>
                                    <div class="expandable-content" id="gtAnswer">
                                        ${currentQuestion.manual_answer}
                                    </div>
                                </div>
                                
                                <h4>Ground Truth Key Facts</h4>
                                <p><em>Check the box for each point covered by the AI.</em></p>
                                
                                <div id="gtEssentialFacts"></div>
                                <div id="gtOptionalFacts"></div>
                            </div>
                            
                            <div class="column">
                                <div class="expandable">
                                    <div class="expandable-header" onclick="toggleExpandable('modelAnswer')">
                                        Show Full Assistant Answer
                                        <span>▼</span>
                                    </div>
                                    <div class="expandable-content" id="modelAnswer">
                                        ${currentQuestion.model_answer}
                                    </div>
                                </div>
                                
                                <h4>AI Assistant's Key Facts (for reference)</h4>
                                <p><em>&nbsp;</em></p>
                                
                                <div id="modelEssentialFacts"></div>
                                <div id="modelOptionalFacts"></div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (currentStep === 2) {
                stepContent = `
                    <div class="question-header">
                        <h2>Question ${currentIndex + 1}/${questions.length}</h2>
                    </div>

                    <!-- Step 2: Correctness -->
                    <div class="section">
                        <h3>Step 2: Evaluate Key Fact Correctness</h3>
                        <div class="question-text">${currentQuestion.question}</div>
                        <p style="margin: 20px 0 10px;"><em>Check the box if a fact is correct. Click "Not Mentioned" if it was not stated in the Ground Truth. If a fact is mentioned but incorrect, simply leave the box unchecked.</em></p>
                        
                        <div class="two-column">
                            <div class="column">
                                <div class="expandable">
                                    <div class="expandable-header" onclick="toggleExpandable('gtAnswer')">
                                        Show Full Ground Truth Answer
                                        <span>▼</span>
                                    </div>
                                    <div class="expandable-content" id="gtAnswer">
                                        ${currentQuestion.manual_answer}
                                    </div>
                                </div>
                                <h4>Ground Truth Key Facts (for reference)</h4>
                                <div id="gtCorrectnessFacts"></div>
                            </div>
                            
                            <div class="column">
                                <div class="expandable">
                                    <div class="expandable-header" onclick="toggleExpandable('modelAnswer')">
                                        Show Full Assistant Answer
                                        <span>▼</span>
                                    </div>
                                    <div class="expandable-content" id="modelAnswer">
                                        ${currentQuestion.model_answer}
                                    </div>
                                </div>
                                <h4>AI Assistant's Key Facts</h4>
                                <div id="modelCorrectnessFacts"></div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (currentStep === 3) {
                stepContent = `
                    <div class="question-header">
                        <h2>Question ${currentIndex + 1}/${questions.length}</h2>
                    </div>

                    <!-- Step 3: Evaluate Relevance and Actionability -->
                    <div class="section">
                        <h3>Step 3: Evaluate Relevance and Actionability</h3>
                        <div class="question-text">${currentQuestion.question}</div>
                        
                        <div class="column">
                            <h4>Relevance Evaluation</h4>
                            <p><em>Check the box for each fact that is relevant to the question.</em></p>
                            <div id="relevanceFacts"></div>
                            
                            <div class="divider"></div>
                            
                            <h4>Actionability Evaluation</h4>
                            <p><em>Click the checkbox if the AI Assistant's key facts represent an actionable response.</em></p>
                            <div class="fact-item">
                                <input type="checkbox" id="actionability" class="fact-checkbox">
                                <label for="actionability" class="fact-text">The assistant response represents actionability (is actionable)</label>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            mainContent.innerHTML = stepContent;

            // Render the facts based on current step
            if (currentStep === 1) {
                renderGroundTruthFacts();
                renderModelFacts();
                // Restore saved state if resuming
                if (isResuming && results[currentQuestion.id]) {
                    restoreSavedState(currentQuestion.id, 1);
                }
            } else if (currentStep === 2) {
                renderCorrectnessFacts();
                // Restore saved state if resuming
                if (isResuming && results[currentQuestion.id]) {
                    restoreSavedState(currentQuestion.id, 2);
                }
            } else if (currentStep === 3) {
                renderRelevanceAndActionabilityFacts();
                // Restore saved state if resuming
                if (isResuming && results[currentQuestion.id]) {
                    restoreSavedState(currentQuestion.id, 3);
                }
            }
            
            // Update navigation
            updateNavigation();
        }

        function updateInstructions() {
            const instructionsSection = document.getElementById('instructionsSection');
            
            if (currentStep === 1) {
                instructionsSection.innerHTML = `
                    <h3>Step 1: Key Fact Coverage Evaluation</h3>
                    <p><strong>Objective:</strong> Evaluate the completeness and risk awareness of the AI assistant's response.</p>
                    
                    <div style="background: rgba(255,255,255,0.4); padding: 20px; border-radius: 10px; margin: 20px 0; backdrop-filter: blur(10px);">
                        <h4 style="color: #1565c0; margin-bottom: 15px;">📋 How to Evaluate:</h4>
                        <ol style="margin-left: 20px;">
                            <li><strong>Review Ground Truth Key Facts:</strong> Examine all the key facts from the car manual (ground truth) that should be covered.</li>
                            <li><strong>Compare with AI Assistant Response:</strong> Check which ground truth key facts are actually mentioned or covered in the AI assistant's response.</li>
                            <li><strong>Mark Coverage:</strong> Tick the checkbox for each ground truth key fact that is covered by the AI assistant.</li>
                            <li><strong>Consider Safety Awareness:</strong> Some key facts are safety-critical. We'll calculate how many safety-related points are covered to assess risk awareness.</li>
                        </ol>
                    </div>
                `;
            } else if (currentStep === 2) {
                instructionsSection.innerHTML = `
                    <h3>Step 2: Key Fact Correctness Evaluation</h3>
                    <p><strong>Objective:</strong> Assess the accuracy of the AI assistant's stated facts by cross-referencing with ground truth.</p>
                    
                    <div style="background: rgba(255,255,255,0.4); padding: 20px; border-radius: 10px; margin: 20px 0; backdrop-filter: blur(10px);">
                        <h4 style="color: #1565c0; margin-bottom: 15px;">✅ How to Evaluate:</h4>
                        <ol style="margin-left: 20px;">
                            <li><strong>Review AI Assistant Key Facts:</strong> Examine each key fact stated by the AI assistant.</li>
                            <li><strong>Cross-reference with Ground Truth:</strong> Check if each AI assistant key fact appears in the ground truth key facts.</li>
                            <li><strong>Mark Correctness:</strong>
                                <ul style="margin-left: 20px; margin-top: 10px;">
                                    <li><strong>✅ Correct:</strong> If the fact is present in ground truth and accurate, check the box.</li>
                                    <li><strong>❌ Incorrect:</strong> If the fact is mentioned but wrong, leave the box unchecked.</li>
                                    <li><strong>🚫 Not Mentioned:</strong> If the fact is not in ground truth, click "Not Mentioned" button.</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                `;
            } else if (currentStep === 3) {
                instructionsSection.innerHTML = `
                    <h3>Step 3: Relevance and Actionability Evaluation</h3>
                    <p><strong>Objective:</strong> Determine the relevance of AI assistant facts to the question and assess overall actionability.</p>
                    
                    <div style="background: rgba(255,255,255,0.4); padding: 20px; border-radius: 10px; margin: 20px 0; backdrop-filter: blur(10px);">
                        <h4 style="color: #1565c0; margin-bottom: 15px;">🎯 Relevance Evaluation:</h4>
                        <p>For each AI assistant key fact, determine if it is relevant to answering the user's question:</p>
                        <ul style="margin-left: 20px;">
                            <li><strong>✅ Relevant:</strong> Check the box if the fact directly addresses the question or provides useful context.</li>
                            <li><strong>❌ Irrelevant:</strong> Leave unchecked if the fact is off-topic or doesn't contribute to answering the question.</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.4); padding: 20px; border-radius: 10px; margin: 20px 0; backdrop-filter: blur(10px);">
                        <h4 style="color: #1565c0; margin-bottom: 15px;">⚡ Actionability Evaluation:</h4>
                        <p>Determine if the overall response enables the user to take concrete action or advance their understanding:</p>
                        <ul style="margin-left: 20px;">
                            <li><strong>✅ Actionable:</strong> Check the box if the response provides clear next steps, specific instructions, meaningful guidance that helps the user complete a task, or information that meaningfully advances their understanding of the topic.</li>
                            <li><strong>❌ Not Actionable:</strong> Leave unchecked if the response is too vague to act upon or doesn't provide any useful information or guidance.</li>
                        </ul>
                    </div>
                `;
            }
        }

        function deduplicateKeyFacts(keyFacts) {
            const safetySet = new Set((keyFacts.safety_critical || []));
            return {
                essential: (keyFacts.essential || []).filter(fact => !safetySet.has(fact)),
                optional: (keyFacts.optional || []).filter(fact => !safetySet.has(fact)),
                safety_critical: keyFacts.safety_critical || []
            };
        }

        // Utility to get unique union of all key points
        function getAllUniqueKeyPoints(manual) {
            const all = [
                ...(manual.essential || []),
                ...(manual.optional || []),
                ...(manual.safety_critical || [])
            ];
            // Remove duplicates
            return Array.from(new Set(all));
        }
        function getUniqueSafetyKeyPoints(manual) {
            // Only those safety critical key points that are not in essential or optional
            const nonDupSafety = (manual.safety_critical || []).filter(fact =>
                !(manual.essential || []).includes(fact) && !(manual.optional || []).includes(fact)
            );
            return nonDupSafety;
        }

        function getDedupedKeyPoints(keyFacts) {
            // Show all essential and optional, then only safety criticals not present in essential/optional
            const essential = keyFacts.essential || [];
            const optional = keyFacts.optional || [];
            const safety_critical = (keyFacts.safety_critical || []).filter(fact =>
                !essential.includes(fact) && !optional.includes(fact)
            );
            return {
                essential,
                optional,
                safety_critical
            };
        }

        function renderGroundTruthFacts() {
            const currentQuestion = questions[currentIndex];
            const deduped = getDedupedKeyPoints(currentQuestion.key_facts_manual);
            let idx = 1;
            
            // Combine all facts into a single list
            const allFacts = [
                ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
            ];
            
            // Essential facts
            const gtEssentialDiv = document.getElementById('gtEssentialFacts');
            gtEssentialDiv.innerHTML = allFacts.map(({ fact, type }) => `
                <div class="fact-item">
                    <input type="checkbox" id="gt_${type}_${idx}" class="fact-checkbox">
                    <div class="fact-text">${idx++}. ${fact}</div>
                </div>
            `).join('');
            
            // Optional facts (empty since we combined everything above)
            const gtOptionalDiv = document.getElementById('gtOptionalFacts');
            gtOptionalDiv.innerHTML = '';
            
            // Safety critical facts (empty since we combined everything above)
            let gtSafetyDiv = document.getElementById('gtSafetyFacts');
            if (!gtSafetyDiv) {
                gtSafetyDiv = document.createElement('div');
                gtSafetyDiv.id = 'gtSafetyFacts';
                gtOptionalDiv.parentNode.appendChild(gtSafetyDiv);
            }
            gtSafetyDiv.innerHTML = '';
        }

        function renderModelFacts() {
            const currentQuestion = questions[currentIndex];
            // Debug: print the full question object
            console.log('Current question:', currentQuestion);
            // Use key_facts if present, otherwise fallback to key_facts_model (for sample data)
            const modelKeyFacts = currentQuestion.key_facts || currentQuestion.key_facts_model;
            if (!modelKeyFacts) {
                console.log('Model key facts are missing for this question:', currentQuestion);
                return;
            }
            // Debug logging
            console.log('Model key facts:', modelKeyFacts);
            const deduped = getDedupedKeyPoints(modelKeyFacts);
            console.log('Deduped key facts:', deduped);
            let idx = 1;
            
            // Combine all facts into a single list with continuous numbering
            const allModelFacts = [
                ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
            ];
            console.log('All model facts:', allModelFacts);
            
            const modelEssentialDiv = document.getElementById('modelEssentialFacts');
            modelEssentialDiv.innerHTML = allModelFacts.map(({ fact, type }) => `
                <div class="fact-item">
                    <div class="fact-text">${idx++}. ${fact}</div>
                </div>
            `).join('');
            
            // Optional facts (empty since we combined everything above)
            const modelOptionalDiv = document.getElementById('modelOptionalFacts');
            modelOptionalDiv.innerHTML = '';
            
            // Safety critical facts (empty since we combined everything above)
            let modelSafetyDiv = document.getElementById('modelSafetyFacts');
            if (!modelSafetyDiv) {
                modelSafetyDiv = document.createElement('div');
                modelSafetyDiv.id = 'modelSafetyFacts';
                modelOptionalDiv.parentNode.appendChild(modelSafetyDiv);
            }
            modelSafetyDiv.innerHTML = '';
        }

        function renderCorrectnessFacts() {
            const currentQuestion = questions[currentIndex];
            const dedupedManual = getDedupedKeyPoints(currentQuestion.key_facts_manual);
            const dedupedModel = getDedupedKeyPoints(currentQuestion.key_facts_model);
            
            // Ground truth facts for reference
            let idx = 1;
            const gtCorrectnessDiv = document.getElementById('gtCorrectnessFacts');
            const allGtFacts = [
                ...dedupedManual.essential.map(fact => ({ fact, type: 'essential' })),
                ...dedupedManual.optional.map(fact => ({ fact, type: 'optional' })),
                ...dedupedManual.safety_critical.map(fact => ({ fact, type: 'safety' }))
            ];
            gtCorrectnessDiv.innerHTML = allGtFacts.map(({ fact }) => `
                <div class="fact-item">
                    <div class="fact-text">${idx++}. ${fact}</div>
                </div>
            `).join('');

            // Model facts with evaluation options using checkboxes
            let midx = 1;
            const modelCorrectnessDiv = document.getElementById('modelCorrectnessFacts');
            const allModelFacts = [
                ...dedupedModel.essential.map(fact => ({ fact, type: 'essential' })),
                ...dedupedModel.optional.map(fact => ({ fact, type: 'optional' })),
                ...dedupedModel.safety_critical.map(fact => ({ fact, type: 'safety' }))
            ];
            modelCorrectnessDiv.innerHTML = allModelFacts.map(({ fact, type }, index) => `
                <div class="fact-item" id="eval_row_${type}_${index}">
                    <input type="checkbox" name="correctness_${type}_${index}_correct" class="fact-checkbox" onchange="handleNotMentionedChange('${type}', ${index})">
                    <div class="fact-text">${midx++}. ${fact}</div>
                    <button type="button" class="not-mentioned-btn" id="not_mentioned_btn_${type}_${index}" onclick="toggleNotMentioned('${type}', ${index})">
                        Not Mentioned
                    </button>
                    <input type="hidden" name="correctness_${type}_${index}_not_mentioned" value="false">
                </div>
            `).join('');
        }

        function renderRelevanceAndActionabilityFacts() {
            const currentQuestion = questions[currentIndex];
            const dedupedModel = getDedupedKeyPoints(currentQuestion.key_facts_model);
            let idx = 1;
            const modelRelevanceDiv = document.getElementById('relevanceFacts');
            
            const allModelFacts = [
                ...dedupedModel.essential.map(fact => ({ fact, type: 'essential' })),
                ...dedupedModel.optional.map(fact => ({ fact, type: 'optional' })),
                ...dedupedModel.safety_critical.map(fact => ({ fact, type: 'safety' }))
            ];
            
            modelRelevanceDiv.innerHTML = allModelFacts.map(({ fact, type }) => `
                <div class="fact-item">
                    <input type="checkbox" id="relevance_relevant_${type}_${idx}" class="fact-checkbox">
                    <div class="fact-text">${idx++}. ${fact}</div>
                </div>
            `).join('');
        }

        function updateNavigation() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const finishBtn = document.querySelector('button[onclick="finishAndSave()"]');

            // Handle step navigation
            if (currentStep === 1) {
                prevBtn.disabled = currentIndex === 0;
                nextBtn.textContent = 'Next Step ➡️';
            } else if (currentStep === 2) {
                prevBtn.disabled = false;
                prevBtn.textContent = '⬅️ Previous Step';
                nextBtn.textContent = 'Next Step ➡️';
            } else if (currentStep === 3) {
                prevBtn.disabled = false;
                prevBtn.textContent = '⬅️ Previous Step';
                if (currentIndex < questions.length - 1) {
                    nextBtn.textContent = 'Next Question ➡️';
                } else {
                    nextBtn.textContent = 'Finish ➡️';
                }
            }

            // Calculate progress based on current question and step
            const totalSteps = questions.length * 3;
            const currentProgress = (currentIndex * 3 + currentStep);
            const progress = (currentProgress / totalSteps) * 100;
            
            progressFill.style.width = progress + '%';
            progressText.textContent = `Question ${currentIndex + 1}/${questions.length}`;

            // Disable finish button until all questions are completed
            const allQuestionsCompleted = checkAllQuestionsCompleted();
            finishBtn.disabled = !allQuestionsCompleted;
        }

        function checkAllQuestionsCompleted() {
            // Check if all questions have been visited (at least started)
            for (let i = 0; i < questions.length; i++) {
                const qId = questions[i].id;
                if (!results[qId]) {
                    return false;
                }
            }
            return true;
        }

        function toggleExpandable(id) {
            const content = document.getElementById(id);
            const header = content.previousElementSibling;
            const arrow = header.querySelector('span');
            
            content.classList.toggle('show');
            arrow.textContent = content.classList.contains('show') ? '▼' : '▶';
        }

        function saveCurrentState() {
            const currentQuestion = questions[currentIndex];
            const qId = currentQuestion.id;
            const dedupedManual = deduplicateKeyFacts(currentQuestion.key_facts_manual);
            const dedupedModel = deduplicateKeyFacts(currentQuestion.key_facts_model);

            // Initialize results for this question if not exists
            if (!results[qId]) {
                results[qId] = {
                    question_id: qId,
                    question_text: currentQuestion.question,
                };
            }

            // Collect data based on current step
            if (currentStep === 1) {
                // Collect completeness data from combined list
                const allCheckboxes = Array.from(document.querySelectorAll('#gtEssentialFacts input[type="checkbox"]'));
                const allChecked = allCheckboxes.map(cb => cb.checked);
                
                // Get the deduped facts to match with checkboxes
                const deduped = getDedupedKeyPoints(currentQuestion.key_facts_manual);
                const allFacts = [
                    ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                    ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                    ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
                ];
                
                // Count covered facts by type
                let coveredEssential = 0;
                let coveredOptional = 0;
                let coveredSafety = 0;
                
                allFacts.forEach(({ fact, type }, index) => {
                    if (allChecked[index]) {
                        if (type === 'essential') coveredEssential++;
                        else if (type === 'optional') coveredOptional++;
                        else if (type === 'safety') coveredSafety++;
                    }
                });
                
                // For safety critical, we need to count ALL safety critical points that are covered
                // This includes both the deduplicated ones shown in UI and those that appear in essential/optional
                const allSafetyCritical = (currentQuestion.key_facts_manual.safety_critical || []);
                let totalSafetyCovered = 0;
                
                // Count safety critical points that appear in essential and are covered
                allSafetyCritical.forEach(safetyFact => {
                    const essentialIndex = (currentQuestion.key_facts_manual.essential || []).indexOf(safetyFact);
                    if (essentialIndex >= 0) {
                        // This safety fact is in essential, check if the corresponding essential fact is covered
                        const essentialFacts = (currentQuestion.key_facts_manual.essential || []);
                        const allFacts = [
                            ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                            ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                            ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
                        ];
                        
                        const factIndex = allFacts.findIndex(({ fact }) => fact === safetyFact);
                        if (factIndex >= 0 && allChecked[factIndex]) {
                            totalSafetyCovered++;
                        }
                    } else {
                        const optionalIndex = (currentQuestion.key_facts_manual.optional || []).indexOf(safetyFact);
                        if (optionalIndex >= 0) {
                            // This safety fact is in optional, check if the corresponding optional fact is covered
                            const allFacts = [
                                ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                                ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                                ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
                            ];
                            
                            const factIndex = allFacts.findIndex(({ fact }) => fact === safetyFact);
                            if (factIndex >= 0 && allChecked[factIndex]) {
                                totalSafetyCovered++;
                            }
                        } else {
                            // This safety fact is unique (not in essential/optional), it's already counted in coveredSafety
                            // But we need to find which unique safety fact this is
                            const uniqueSafetyFacts = deduped.safety_critical;
                            const uniqueIndex = uniqueSafetyFacts.indexOf(safetyFact);
                            if (uniqueIndex >= 0) {
                                // Find the corresponding checkbox in the combined list
                                const allFacts = [
                                    ...deduped.essential.map(fact => ({ fact, type: 'essential' })),
                                    ...deduped.optional.map(fact => ({ fact, type: 'optional' })),
                                    ...deduped.safety_critical.map(fact => ({ fact, type: 'safety' }))
                                ];
                                
                                const factIndex = allFacts.findIndex(({ fact }) => fact === safetyFact);
                                if (factIndex >= 0 && allChecked[factIndex]) {
                                    totalSafetyCovered++;
                                }
                            }
                        }
                    }
                });
                
                const totalEssentialGT = (currentQuestion.key_facts_manual.essential || []).length;
                const totalOptionalGT = (currentQuestion.key_facts_manual.optional || []).length;
                
                results[qId].essential_covered = `${coveredEssential}/${totalEssentialGT}`;
                results[qId].optional_covered = `${coveredOptional}/${totalOptionalGT}`;
                results[qId].safety_covered = `${totalSafetyCovered}/${allSafetyCritical.length}`;
                
                // For all covered: count all checked boxes, denominator is unique union
                const allCovered = allChecked.filter(c => c).length;
                const allUnique = getAllUniqueKeyPoints(currentQuestion.key_facts_manual).length;
                results[qId].all_covered = `${allCovered}/${allUnique}`;

            } else if (currentStep === 2) {
                // Collect correctness data from the deduplicated structure
                const dedupedModel = getDedupedKeyPoints(currentQuestion.key_facts_model);
                const allModelFacts = [
                    ...dedupedModel.essential.map(fact => ({ fact, type: 'essential' })),
                    ...dedupedModel.optional.map(fact => ({ fact, type: 'optional' })),
                    ...dedupedModel.safety_critical.map(fact => ({ fact, type: 'safety' }))
                ];
                
                const essentialCorrectness = [];
                const optionalCorrectness = [];
                const safetyCorrectness = [];
                let mentionedEssentialCount = 0;
                let mentionedOptionalCount = 0;
                let mentionedSafetyCount = 0;
                
                allModelFacts.forEach(({ fact, type }, index) => {
                    const notMentioned = document.querySelector(`input[name="correctness_${type}_${index}_not_mentioned"]`).value === 'true';
                    if (!notMentioned) {
                        const isCorrect = document.querySelector(`input[name="correctness_${type}_${index}_correct"]`).checked;
                        if (type === 'essential') {
                            mentionedEssentialCount++;
                            if (isCorrect) essentialCorrectness.push(true);
                        } else if (type === 'optional') {
                            mentionedOptionalCount++;
                            if (isCorrect) optionalCorrectness.push(true);
                        } else if (type === 'safety') {
                            mentionedSafetyCount++;
                            if (isCorrect) safetyCorrectness.push(true);
                        }
                    }
                });

                const accurateEssential = essentialCorrectness.length;
                const accurateOptional = optionalCorrectness.length;
                const accurateSafety = safetyCorrectness.length;
                
                results[qId].mentioned_correct_essential = `${accurateEssential}/${mentionedEssentialCount}`;
                results[qId].mentioned_correct_all = `${accurateEssential + accurateOptional + accurateSafety}/${mentionedEssentialCount + mentionedOptionalCount + mentionedSafetyCount}`;

            } else if (currentStep === 3) {
                // Collect relevance and actionability data from the deduplicated structure
                const dedupedModel = getDedupedKeyPoints(currentQuestion.key_facts_model);
                const allModelFacts = [
                    ...dedupedModel.essential.map(fact => ({ fact, type: 'essential' })),
                    ...dedupedModel.optional.map(fact => ({ fact, type: 'optional' })),
                    ...dedupedModel.safety_critical.map(fact => ({ fact, type: 'safety' }))
                ];
                
                const essentialRelevance = [];
                const optionalRelevance = [];
                const safetyRelevance = [];
                
                allModelFacts.forEach(({ fact, type }, index) => {
                    const isRelevant = document.querySelector(`input[id="relevance_relevant_${type}_${index + 1}"]`).checked;
                    if (type === 'essential') {
                        essentialRelevance.push(isRelevant);
                    } else if (type === 'optional') {
                        optionalRelevance.push(isRelevant);
                    } else if (type === 'safety') {
                        safetyRelevance.push(isRelevant);
                    }
                });
                
                const isActionable = document.getElementById('actionability').checked;

                const relevantEssential = essentialRelevance.filter(c => c).length;
                const totalEssentialModel = dedupedModel.essential.length;
                const relevantOptional = optionalRelevance.filter(c => c).length;
                const totalOptionalModel = dedupedModel.optional.length;
                const relevantSafety = safetyRelevance.filter(c => c).length;
                const totalSafetyModel = dedupedModel.safety_critical.length;

                results[qId].relevance = `${relevantEssential + relevantOptional + relevantSafety}/${totalEssentialModel + totalOptionalModel + totalSafetyModel}`;
                results[qId].is_actionable = isActionable ? 1 : 0;
            }

            // Auto-save to Firebase after each question completion
            if (currentStep === 3) {
                autoSaveToFirebase();
            }
        }

        function autoSaveToFirebase() {
            if (!sessionId) {
                // Create new session ID if not exists
                sessionId = `session_${new Date().toISOString().replace(/[:.]/g, '-')}`;
            }

            const annotatorName = document.getElementById('annotatorName').value.trim() || 'Anonymous';
            
            const autoSaveData = {
                session_id: sessionId,
                annotator_name: annotatorName,
                current_question_index: currentIndex,
                current_step: currentStep,
                results: results,
                last_updated: new Date().toISOString(),
                total_questions: questions.length,
                metadata: {
                    sampleFraction: SAMPLE_FRACTION,
                    manualFile: MANUAL_FILE,
                    modelFile: MODEL_FILE
                }
            };

            console.log('🔄 Auto-saving progress to Firebase...', autoSaveData);

            // Save to Firebase
            db.collection('evaluation_sessions').doc(sessionId).set(autoSaveData)
                .then(() => {
                    console.log('✅ Auto-save successful');
                    // Show a subtle indicator that progress was saved
                    showAutoSaveIndicator();
                })
                .catch((error) => {
                    console.error('❌ Auto-save failed:', error);
                    // Don't show error to user for auto-save failures
                });
        }

        function showAutoSaveIndicator() {
            // Create or update auto-save indicator
            let indicator = document.getElementById('autoSaveIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autoSaveIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #28a745;
                    color: white;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 12px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }
            
            indicator.textContent = '💾 Progress saved';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        function previousQuestion() {
            saveCurrentState();
            
            if (currentStep > 1) {
                // Go to previous step
                currentStep--;
            } else if (currentIndex > 0) {
                // Go to previous question, last step
                currentIndex--;
                currentStep = 3;
            }
            
            updateUI();
        }

        function nextQuestion() {
            saveCurrentState();
            
            if (currentStep < 3) {
                // Go to next step
                currentStep++;
            } else if (currentIndex < questions.length - 1) {
                // Go to next question, first step
                currentIndex++;
                currentStep = 1;
            } else {
                // Finished all questions
                finishAndSave();
                return;
            }
            
            updateUI();
        }

        function finishAndSave() {
            saveCurrentState();
            saveResultsToFile();
        }

        function saveResultsToFile() {
            const finalResults = Object.values(results);
            const annotatorName = document.getElementById('annotatorName').value.trim() || 'Anonymous';
            
            // Save to Firebase Firestore
            const timestamp = new Date().toISOString();
            const evaluationId = `evaluation_${timestamp.replace(/[:.]/g, '-')}`;
            
            // Show loading message
            const successMessage = document.getElementById('successMessage');
            successMessage.textContent = 'Saving results...';
            successMessage.style.display = 'block';
            
            console.log('=== SAVE PROCESS START ===');
            console.log('Current auth state:', auth.currentUser);
            console.log('Evaluation ID:', evaluationId);
            console.log('Annotator Name:', annotatorName);
            console.log('Results to save:', finalResults);
            
            // Try to save to Firebase first
            saveToFirestore()
                .then(() => {
                    console.log('✅ Firebase save successful!');
                    showThankYouPage(evaluationId, finalResults);
                })
                .catch((error) => {
                    console.error('❌ Firebase save failed:', error);
                    console.error('Error details:', {
                        code: error.code,
                        message: error.message,
                        stack: error.stack
                    });
                    // Fallback to local save
                    saveLocally(finalResults, evaluationId);
                });
            
            function saveToFirestore() {
                return new Promise((resolve, reject) => {
                    console.log('🔄 Starting Firebase save process...');
                    
                    // Check if we can write to Firestore
                    if (!auth.currentUser) {
                        console.log('⚠️ No authenticated user, trying to sign in...');
                        auth.signInAnonymously()
                            .then((result) => {
                                console.log('✅ Anonymous sign-in successful:', result.user.uid);
                                performFirestoreSave();
                            })
                            .catch((error) => {
                                console.error('❌ Anonymous sign-in failed:', error);
                                let errorMessage = 'Authentication failed: ' + error.message;
                                
                                // Provide specific help for common issues
                                if (error.code === 'auth/configuration-not-found') {
                                    errorMessage = 'Anonymous Authentication is not enabled in Firebase. Please enable it in the Firebase Console under Authentication > Sign-in methods > Anonymous.';
                                } else if (error.code === 'auth/network-request-failed') {
                                    errorMessage = 'Network error. Please check your internet connection.';
                                }
                                
                                reject(new Error(errorMessage));
                            });
                    } else {
                        console.log('✅ User already authenticated:', auth.currentUser.uid);
                        performFirestoreSave();
                    }
                    
                    function performFirestoreSave() {
                        console.log('🔄 Attempting to write to Firestore...');
                        console.log('Collection: evaluations, Document: ' + evaluationId);
                        
                        const dataToSave = {
                            timestamp: timestamp,
                            annotator_name: annotatorName,
                            totalQuestions: questions.length,
                            results: finalResults,
                            metadata: {
                                sampleFraction: SAMPLE_FRACTION,
                                manualFile: MANUAL_FILE,
                                modelFile: MODEL_FILE
                            }
                        };
                        
                        console.log('📊 Data to save:', dataToSave);
                        
                        db.collection('evaluations').doc(evaluationId).set(dataToSave)
                            .then(() => {
                                console.log('✅ Firestore write successful!');
                                resolve();
                            })
                            .catch((error) => {
                                console.error('❌ Firestore write failed with error:', error);
                                console.error('Error code:', error.code);
                                console.error('Error message:', error.message);
                                reject(error);
                            });
                    }
                });
            }
            
            function saveLocally(results, evaluationId) {
                console.log('🔄 Falling back to local save...');
                
                // Create data with annotator name
                const dataToSave = {
                    evaluation_id: evaluationId,
                    timestamp: timestamp,
                    annotator_name: annotatorName,
                    total_questions: questions.length,
                    results: results,
                    metadata: {
                        sampleFraction: SAMPLE_FRACTION,
                        manualFile: MANUAL_FILE,
                        modelFile: MODEL_FILE
                    }
                };
                
                // Create a downloadable version as fallback
                const dataStr = JSON.stringify(dataToSave, null, 4);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `evaluation_results_${annotatorName.replace(/[^a-zA-Z0-9]/g, '_')}_${evaluationId}.json`;
                link.click();
                
                // Show thank you page with local save message
                showThankYouPage(evaluationId, results, true);
                
                // Show info message
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Results saved locally. Firebase authentication failed.';
                errorMessage.style.display = 'block';
                errorMessage.style.background = '#d1ecf1';
                errorMessage.style.color = '#0c5460';
                setTimeout(() => {
                    errorMessage.style.display = 'none';
                }, 5000);
            }
        }

        function handleNotMentionedChange(type, index) {
            const notMentionedCheckbox = document.querySelector(`input[name="correctness_${type}_${index}_not_mentioned"]`);
            const row = document.getElementById(`eval_row_${type}_${index}`);
            const correctCheckbox = document.querySelector(`input[name="correctness_${type}_${index}_correct"]`);
            
            if (notMentionedCheckbox.checked) {
                // If "Not Mentioned" is checked, fade out the row and uncheck other options
                row.classList.add('faded');
                if (correctCheckbox) correctCheckbox.checked = false;
            } else {
                // If "Not Mentioned" is unchecked, restore the row
                row.classList.remove('faded');
            }
        }

        function toggleNotMentioned(type, index) {
            const notMentionedInput = document.querySelector(`input[name="correctness_${type}_${index}_not_mentioned"]`);
            const notMentionedBtn = document.getElementById(`not_mentioned_btn_${type}_${index}`);
            const row = document.getElementById(`eval_row_${type}_${index}`);
            const correctCheckbox = document.querySelector(`input[name="correctness_${type}_${index}_correct"]`);
            
            // Toggle the state
            const isNotMentioned = notMentionedInput.value === 'true';
            
            if (!isNotMentioned) {
                // Activate "Not Mentioned" state
                notMentionedInput.value = 'true';
                notMentionedBtn.classList.add('active');
                row.classList.add('faded');
                if (correctCheckbox) correctCheckbox.checked = false;
            } else {
                // Deactivate "Not Mentioned" state
                notMentionedInput.value = 'false';
                notMentionedBtn.classList.remove('active');
                row.classList.remove('faded');
            }
        }

        function restartEvaluation() {
            // Reset all state
            currentIndex = 0;
            currentStep = 1;
            results = {};
            
            // Hide thank you page
            document.getElementById('thankYouPage').style.display = 'none';
            
            // Show main content and sidebar
            document.getElementById('mainContent').style.display = 'block';
            document.querySelector('.sidebar').style.display = 'block';
            
            // Reload data and update UI
            loadAndPrepareData();
        }

        function showThankYouPage(evaluationId, results, isLocalSave = false) {
            // Hide main content and sidebar
            document.getElementById('mainContent').style.display = 'none';
            document.querySelector('.sidebar').style.display = 'none';
            
            // Show thank you page
            const thankYouPage = document.getElementById('thankYouPage');
            thankYouPage.style.display = 'block';
            
            // Get annotator name
            const annotatorName = document.getElementById('annotatorName').value.trim() || 'Anonymous';
            
            // Set evaluation ID
            document.getElementById('evaluationIdSpan').textContent = evaluationId;
            
            // Update title if it's a local save
            if (isLocalSave) {
                document.querySelector('#thankYouPage h1').textContent = '🎉 Thank You! (Local Save)';
                document.querySelector('#thankYouPage h2').textContent = 'Your evaluation has been saved locally';
            }
            
            // Calculate and display statistics
            const statsGrid = document.getElementById('statsGrid');
            const totalQuestions = results.length;
            const totalEvaluations = results.reduce((sum, result) => {
                return sum + (result.covered_essential_ground_truth || 0) + (result.covered_optional_ground_truth || 0);
            }, 0);
            
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${annotatorName}</div>
                    <div class="stat-label">Annotator</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalQuestions}</div>
                    <div class="stat-label">Questions Evaluated</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalEvaluations}</div>
                    <div class="stat-label">Total Evaluations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${new Date().toLocaleDateString()}</div>
                    <div class="stat-label">Completion Date</div>
                </div>
            `;
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function checkForExistingSessions() {
            const annotatorName = document.getElementById('annotatorName').value.trim() || 'Anonymous';
            
            // Wait for Firebase to be ready
            setTimeout(() => {
                if (auth.currentUser) {
                    console.log('🔍 Checking for existing sessions...');
                    
                    db.collection('evaluation_sessions')
                        .where('annotator_name', '==', annotatorName)
                        .where('last_updated', '>', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()) // Last 24 hours
                        .orderBy('last_updated', 'desc')
                        .limit(1)
                        .get()
                        .then((querySnapshot) => {
                            if (!querySnapshot.empty) {
                                const sessionData = querySnapshot.docs[0].data();
                                console.log('📋 Found existing session:', sessionData);
                                
                                // Show resume dialog
                                showResumeDialog(sessionData);
                            }
                        })
                        .catch((error) => {
                            console.error('❌ Error checking for sessions:', error);
                        });
                }
            }, 2000); // Wait 2 seconds for Firebase to initialize
        }

        function showResumeDialog(sessionData) {
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.4);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;
            
            const content = document.createElement('div');
            content.className = 'resume-dialog';
            content.style.cssText = `
                background: linear-gradient(135deg, #e8f5e8 0%, #f0f8f0 100%);
                padding: 40px;
                border-radius: 20px;
                max-width: 550px;
                text-align: center;
                box-shadow: 0 15px 40px rgba(0,0,0,0.3);
                border: 2px solid rgba(76, 175, 80, 0.3);
                backdrop-filter: blur(10px);
                color: #2c5530;
            `;
            
            const lastUpdated = new Date(sessionData.last_updated).toLocaleString();
            const progress = Math.round((Object.keys(sessionData.results).length / sessionData.total_questions) * 100);
            
            content.innerHTML = `
                <h3 style="font-size: 1.8rem; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); color: #2c5530;">🔄 Resume Previous Session?</h3>
                <p style="font-size: 1.1rem; margin-bottom: 25px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); color: rgba(44, 85, 48, 0.8);">We found a previous evaluation session for <strong>${sessionData.annotator_name}</strong>.</p>
                <div style="background: rgba(255,255,255,0.6); padding: 20px; border-radius: 12px; margin: 25px 0; backdrop-filter: blur(10px); border: 1px solid rgba(76, 175, 80, 0.2);">
                    <p style="margin-bottom: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); color: #2c5530;"><strong>Progress:</strong> ${Object.keys(sessionData.results).length} of ${sessionData.total_questions} questions (${progress}%)</p>
                    <p style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2); color: #2c5530;"><strong>Last updated:</strong> ${lastUpdated}</p>
                </div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="resumeBtn" style="background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; padding: 15px 30px; border-radius: 12px; cursor: pointer; font-weight: bold; font-size: 1.1rem; box-shadow: 0 8px 32px rgba(0,0,0,0.2); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); transition: all 0.3s ease;">Resume Session</button>
                    <button id="startNewBtn" style="background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); color: white; border: none; padding: 15px 30px; border-radius: 12px; cursor: pointer; font-weight: bold; font-size: 1.1rem; box-shadow: 0 8px 32px rgba(0,0,0,0.2); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); transition: all 0.3s ease;">Start New Session</button>
                </div>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            
            // Add hover effects
            const resumeBtn = document.getElementById('resumeBtn');
            const startNewBtn = document.getElementById('startNewBtn');
            
            resumeBtn.addEventListener('mouseenter', () => {
                resumeBtn.style.background = 'linear-gradient(135deg, #45a049 0%, #4caf50 100%)';
                resumeBtn.style.transform = 'translateY(-2px)';
                resumeBtn.style.boxShadow = '0 12px 40px rgba(0,0,0,0.3)';
            });
            
            resumeBtn.addEventListener('mouseleave', () => {
                resumeBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)';
                resumeBtn.style.transform = 'translateY(0)';
                resumeBtn.style.boxShadow = '0 8px 32px rgba(0,0,0,0.2)';
            });
            
            startNewBtn.addEventListener('mouseenter', () => {
                startNewBtn.style.background = 'linear-gradient(135deg, #5a6268 0%, #6c757d 100%)';
                startNewBtn.style.transform = 'translateY(-2px)';
                startNewBtn.style.boxShadow = '0 12px 40px rgba(0,0,0,0.3)';
            });
            
            startNewBtn.addEventListener('mouseleave', () => {
                startNewBtn.style.background = 'linear-gradient(135deg, #b47a7a 0%, #a06b6b 100%)';
                startNewBtn.style.transform = 'translateY(0)';
                startNewBtn.style.boxShadow = '0 8px 32px rgba(0,0,0,0.2)';
            });
            
            // Handle resume button
            resumeBtn.addEventListener('click', () => {
                resumeSession(sessionData);
                document.body.removeChild(dialog);
            });
            
            // Handle start new button
            startNewBtn.addEventListener('click', () => {
                document.body.removeChild(dialog);
            });
        }

        function resumeSession(sessionData) {
            console.log('🔄 Resuming session:', sessionData.session_id);
            
            // Set session data
            sessionId = sessionData.session_id;
            results = sessionData.results || {};
            currentIndex = sessionData.current_question_index || 0;
            currentStep = sessionData.current_step || 1;
            isResuming = true;
            
            // Set annotator name if not already set
            if (!document.getElementById('annotatorName').value.trim()) {
                document.getElementById('annotatorName').value = sessionData.annotator_name;
            }
            
            // Update UI
            updateUI();
            
            // Show success message
            const successMessage = document.getElementById('successMessage');
            successMessage.textContent = `Session resumed! Continuing from question ${currentIndex + 1}, step ${currentStep}.`;
            successMessage.style.display = 'block';
            successMessage.style.background = '#d4edda';
            successMessage.style.color = '#155724';
            setTimeout(() => {
                successMessage.style.display = 'none';
            }, 5000);
        }

        function restoreSavedState(questionId, step) {
            const savedData = results[questionId];
            if (!savedData) return;

            if (step === 1) {
                // Restore completeness data
                if (savedData.covered_essential_ground_truth !== undefined) {
                    const essentialCheckboxes = document.querySelectorAll('#gtEssentialFacts input[type="checkbox"]');
                    const optionalCheckboxes = document.querySelectorAll('#gtOptionalFacts input[type="checkbox"]');
                    
                    // Restore essential facts (simplified - just check first N boxes)
                    let checkedCount = 0;
                    essentialCheckboxes.forEach((cb, index) => {
                        if (checkedCount < savedData.covered_essential_ground_truth) {
                            cb.checked = true;
                            checkedCount++;
                        } else {
                            cb.checked = false;
                        }
                    });
                    
                    // Restore optional facts
                    checkedCount = 0;
                    optionalCheckboxes.forEach((cb, index) => {
                        if (checkedCount < savedData.covered_optional_ground_truth) {
                            cb.checked = true;
                            checkedCount++;
                        } else {
                            cb.checked = false;
                        }
                    });
                }
            } else if (step === 2) {
                // Restore correctness data (simplified restoration)
                console.log('Restoring correctness data for question:', questionId);
            } else if (step === 3) {
                // Restore relevance and actionability data
                if (savedData.is_actionable !== undefined) {
                    const actionabilityCheckbox = document.getElementById('actionability');
                    if (actionabilityCheckbox) {
                        actionabilityCheckbox.checked = savedData.is_actionable === 1;
                    }
                }
            }
        }
    </script>
</body>
</html> 